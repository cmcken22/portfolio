/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 public/models/Dolphin.glb 
Author: rkuhlf (https://sketchfab.com/rkuhlf)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/dolphin-06db7f1bfe9c46feb17b2df67f8e028d
Title: Dolphin
*/

import React, { useRef, useEffect } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { useControls } from "leva";
import { motion } from "framer-motion-3d";

export function Dolphin(props) {
  const { animation } = props;
  const group = useRef();
  const { nodes, materials, animations } = useGLTF(
    "/portfolio/models/Dolphin.glb"
  );
  const { actions } = useAnimations(animations, group);
  const [animationComplete, setAnimationComplete] = React.useState(false);
  const [dRotation, setDRotation] = React.useState({ x: 0, y: 4, z: 0 });
  const timerRef = useRef();

  const { viewport, ...rest } = useThree();

  console.log("viewport:", viewport);
  console.log("rest:", rest);

  // console.log("actions:", actions);
  // console.log("animations:", animations);

  useEffect(() => {
    if (animation !== "") {
      timerRef.current = setTimeout(() => {
        setAnimationComplete(true);
      }, 3000);
    } else {
      setAnimationComplete(false);
      clearTimeout(timerRef.current);
      setDRotation({ x: 0, y: 4, z: 0 });
    }
    return () => {
      clearTimeout(timerRef.current);
      setDRotation({ x: 0, y: 4, z: 0 });
    };
  }, [animation]);

  const position = useControls("Dolphin Position", {
    value: {
      x: viewport?.width,
      // y: -(viewport?.height / 2),
      y: 0,
      z: 0,
    },
  });
  const scale = useControls("Dolphin Scale", { value: 0.3 });
  const rotation = useControls("Dolphin Rotation", {
    value: {
      x: dRotation.x,
      y: dRotation.y,
      z: dRotation.z,
    },
  });

  console.log("group:", group);
  console.log("animationComplete:", animationComplete);

  useFrame((state) => {
    if (!group?.current) return;
    // if (headFollow) {
    // console.log('group.current.getObjectByName("Sketchfab_Scene"):', group.current.getObjectByName("Sketchfab_Scene"));
    // console.log('state.mouse:', state.mouse);
    // group.current.getObjectByName("Sketchfab_Scene").lookAt(state.mouse.x, state.mouse.y, 1);
    // }
    // if (cursorFollow) {
    // const target = new THREE.Vector3(state.mouse.x, state.mouse.y, 1);
    // group.current.getObjectByName("Sketchfab_Scene").lookAt(target);
    // }
    if (group.current && animation !== "" && animationComplete) {
      // group.current.rotation.x += 0.01; // Rotate around the x-axis
      group.current.rotation.y += 0.001; // Rotate around the y-axis
      // group.current.rotation.z += 0.01; // Rotate around the z-axis
      console.log("group.current:", group.current);
    }
  });

  useEffect(() => {
    if (animation) {
      console.log("yooo:", animation);
      actions[animation].reset().fadeIn(0.5).play();
    } else {
      actions?.["Swim"]?.reset()?.fadeOut(0.5);
    }
    return () => {
      actions?.["Swim"]?.reset()?.fadeOut(0.5);
    };
  }, [animation]);

  if (animation === "") return null;

  return (
    <motion.group
      // position={[0, 0, 0]}
      initial={{ scale: 0.3, opacity: 0 }}
      rotation={[rotation.value.x, rotation.value.y, rotation.value.z]}
      position={[position.value.x, position.value.y, position.value.z]}
      animate={{
        x: animation !== "" ? 0 : position.value.x,
        y:
          animation !== ""
            ? -(viewport?.height / viewport?.initialDpr)
            : position.value.y,
        scale: animation !== "" ? 0.8 : scale.value,
        // opacity
        // z: animation !== "" ? 0 : -10,
        // y: animation !== "" ? -viewport.height : -1.5,
      }}
      transition={{ delay: 1.0, duration: 2 }}
    >
      <motion.group
        ref={group}
        {...props}
        dispose={null}
        // position={[position.value.x, position.value.y, position.value.z]}
        // rotation={[rotation.value.x, rotation.value.y, rotation.value.z]}
        // scale={[scale.value, scale.value, scale.value]}
      >
        <group name="Sketchfab_Scene">
          <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
            <group name="root">
              <group name="GLTF_SceneRootNode" rotation={[Math.PI / 2, 0, 0]}>
                <group
                  name="Armature_18"
                  position={[0, 1.052, 0]}
                  rotation={[0, 0, -1.692]}
                >
                  <group name="GLTF_created_0">
                    <primitive object={nodes.GLTF_created_0_rootJoint} />
                    <group name="Dolphin_17" />
                    <skinnedMesh
                      name="Object_7"
                      geometry={nodes.Object_7.geometry}
                      material={materials.Dolphin}
                      skeleton={nodes.Object_7.skeleton}
                    />
                    <skinnedMesh
                      name="Object_8"
                      geometry={nodes.Object_8.geometry}
                      material={materials.DolphinBelly}
                      skeleton={nodes.Object_8.skeleton}
                    />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </motion.group>
    </motion.group>
  );
}

useGLTF.preload("/portfolio/models/Dolphin.glb");
